/*
* 작성일: 2025.02.20
* 작성자: 김현우
* 주제: 데이터 표현 방식
*/

/*
* 2가지 타입: 정수, 실수 + 문자(숫자)
* int, char, short, long, longlong - 정수
* float, double, decimal - 실수
*/

/* 정수를 표현하는 방법
* - 표현하는 키워드가 많음
* - 이유: 최선의 메모리를 사용하기 위해
* - 컴퓨터 정보를 읽는 최소 단위: 바이트
* - 비트 (0,1) [최소 단위가 아니라]
* 10진수? 2진수?
* 16				00010000 = 2^4x1  2^8 = 256
* 127				01111111(2) <-- 2진수임을 나타냄
* 
* int attackPower; 00000000 00000000 00000000 00000000;
* char ch1;
* 
*/

/* 실수를 표현하는 방식
* - 2 바이트				00000000 00000000
* 8 8 (절반은 상수, 절반은 실수)
* 00000101 00000101 -> 5.5
* 
* 5.4995 // 표현하고자 하는 수가 얼마 차이 나지 않음. 실수를 표현하는 비트의 수가 너무 적다.
* 실수를 표현할 수 있는 범위가 너무 적다.
* 
* 부동소수점 방식(떠다니다) : float
* 
* 125.234091
* 1.25234091 * 10^2
* 
* (정수) * 정규화된 식^(지수)
* 어떤 수를 제곱, 1; (33^0 = 1)
* 
* 부동소수점의 오차가 발생한다.
* 1 = 1.0
* 
*/

/*
* 뺄셈: A - B  A + (-B)
* 정수: 음수를 표현하는 방법
* MSB: Most Signmant Bit
* 데이터 표현방식에서 가장 왼쪽 끝에 있는 비트에 할당한다.
* 
* 5 양수			00000101  4 + 1 = 5
* 그럼 -5 비트로 어떻게 표현할까? = 2의 보수법
* 
* 2의 보수법 - 양수를 비트로 표현하고 모든 비트를 반전시킨다. +1;
* 
*				00000101
*				10000101
*			1	00000000
* 
* 메모리 측면
* unsigned int
*/

/*
* int attackPower = 10 + 1 * 0.3
* 
* 리터럴 상수
* int, double	- int 형 정의, double 형 정의
* 1 * 0.3;		= 0.3
* int 정의 =>		0
* double 정의 =>		0.3
* (반드시 손실이 발생. 정수로 하려면 소수점 아래 숫자가 반드시 날라감)
* 
*/

/*
* 데이터 형 -> 스스로 형태를 바꾼다.
* 형 변환
* - 자동: 묵시적 변환
* - 수동: 명시적 변환(눈에 보이게)
*/


#include <stdio.h>

int main()
{
	int attackPower = 10 + 1 * 0.3; // double 안 넣었는데 자동으로 발생 중. double의 형질이
	double attackPower2 = 10 + 1 * 0.3; // 10.3

	printf("값 : %1f\n", attackPower2); // 정수 표현 방식의 값으로 읽어온다.

	printf("정수의 표현 방식 실습\n");

	char num1 = 129;				// 0000 0000
									// 0011 1111 127
									// 1000 0001

	int num2 = 129;					// 1000 0001 = 129 (마이너스 부호 안 들어가도 되니까 앞에 1 넣어도 됨) int는 32칸의 0이 모두 사용되기에 + 숫자만 사용
	char num3 = num2;				// char는 마지막 숫자를 부호로 사용. 1 111 1111 = -127
	printf("값 : %d\n\n", num3);

	printf("실수의 표현 방식 실습\n");

	float num4 = 0.1;

	for (int i = 0; 1 < 1000; i++)
		num4 += 0.1;

	printf("값 : %f\n", num4);

}